# [s21_matrix+](https://github.com/Tixon-noxit/CPP/tree/main/CPP1_s21_matrixplus)

### Описание
Разработка библиотеки для работы с матрицами на языке C++ с использованием стандартов C++17 и Google Style. Библиотека реализует класс `S21Matrix`, предоставляющий удобные методы для работы с матрицами, а также перегруженные операторы для выполнения различных операций.

### Ключевые особенности

#### Архитектура
- Реализация класса `S21Matrix` с приватными полями `matrix_`, `rows_` и `cols_` для хранения данных матрицы и её размеров.
- Использование аксессоров и мутаторов для управления приватными полями `rows_` и `cols_`.
- Поддержка динамического изменения размеров матрицы с автоматическим заполнением новыми элементами нулями и отбрасыванием лишних элементов при уменьшении.

#### Функциональность
- Реализация основных операций над матрицами, таких как сложение, вычитание, умножение и другие.
- Перегрузка операторов для выполнения математических операций между матрицами.
- Подготовка полного покрытия кода библиотеки тестами с использованием GTest.

#### Инструменты
- Написание Makefile для сборки статической библиотеки `s21_matrix_oop.a` и запуска тестов, включая цели `all`, `clean`, `test`.

#### Технологии
- C++17
- GTest
- Google Style Guide

### Результаты и достижения
В этом проекте я существенно укрепил навыки работы с динамическим управлением памятью в C++. Я научился правильно выделять и освобождать память для двумерных массивов, используя подходы, которые помогают избежать утечек памяти и ошибок.

Также я освоил реализацию различных перегруженных операторов, таких как `+`, `-`, `*`, `+=`, `-=`, `*=`, и операторов доступа по индексу `()` для элементов матрицы, что позволяет использовать класс более интуитивно, как встроенные типы данных. Этот навык углубил моё понимание операционной перегрузки и ее применения в практике.

В процессе работы с матрицами я реализовал сложение, вычитание, умножение матриц, их транспонирование, нахождение детерминанта и обратной матрицы, что дало мне хорошее представление о матричных вычислениях и алгоритмах линейной алгебры. Благодаря этому проекту я также научился выявлять исключительные ситуации, такие как невозможность выполнения операции из-за несовместимых размеров матриц или нулевого детерминанта, и обрабатывать их с помощью исключений.

Наконец, укрепил свои навыки работы с методами перемещения и копирования объектов, что помогло оптимизировать программу, особенно при работе с большими матрицами.

---

# [s21_containers](https://github.com/Tixon-noxit/CPP/tree/main/CPP2_s21_containers)

### Описание
Разработка библиотеки для реализации контейнеров на языке C++ с использованием стандартов C++17. Библиотека включает основные и дополнительные контейнеры, такие как `list`, `map`, `queue`, `set`, `stack`, `vector`, а также методы для вставки нескольких элементов.

### Ключевые особенности

#### Архитектура
- Реализация контейнеров в заголовочном файле `s21_containers.h`, который включает заголовочные файлы с реализациями контейнеров (`s21_list.h`, `s21_map.h` и т.д.).
- Возможность переиспользования общих методов в базовых классах для очередей, стеков, списков и векторов.

#### Функциональность
- Реализация контейнеров: `list`, `map`, `queue`, `set`, `stack`, `vector`.
- Дополнительная библиотека `s21_containersplus.h`, содержащая реализацию контейнеров: массив и мультисет.
- Метод `insert_many`, позволяющий вставлять несколько элементов в контейнеры.

#### Инструменты
- Подготовка Makefile для тестирования библиотеки с целями `clean` и `test`.

#### Технологии
- C++17
- Google Style Guide

### Результаты и достижения

В ходе разработки библиотеки контейнеров на C++17 я освоил проектирование и реализацию основных структур данных, включая `list`, `map`, `queue`, `set`, `stack` и `vector`. 
Я научился:
- Проектировать контейнеры с нуля: это дало понимание их внутренней структуры и реализацию интерфейсов, соответствующих стандартной библиотеке C++.
- Организовывать библиотеку: структура заголовочных файлов для каждого контейнера упростила поддержку и повысила модульность кода.
- Использовать переиспользование кода: общие методы для базовых классов сократили дублирование и улучшили читаемость.
- Создавать пользовательские методы: метод `insert_many` добавил гибкости в работу с контейнерами.
- Проект помог мне укрепить навыки проектирования, шаблонного программирования в C++17.

---

# [BrickGame Snake](https://github.com/Tixon-noxit/CPP/tree/main/CPP3_BrickGame_v2.0)

### Описание
Разработка игры "Snake" в рамках проекта BrickGame v2.0 на C++ с использованием стандарта C++17. Игра состоит из библиотеки для логики игры и графического интерфейса (GUI).

### Ключевые особенности

#### Архитектура
- Проект разделен на две части: библиотека для логики игры в `src/brick_game/snake` и графический интерфейс в `src/gui/desktop`.
- Реализация конечного автомата состояний (FMS) для формализации логики игры.

#### Функциональность
- Механики игры: движение змеи, увеличение длины, окончание игры при столкновении.
- Управление через клавиши-стрелки и возможность ускорения змеи.
- Система уровней: каждые 5 очков увеличивают уровень и скорость змеи.

#### Инструменты
- Использование библиотеки GUI: Qt.
- Реализация паттерна MVC.
- Покрытие кода тестами (минимум 80%) с использованием GTest.
- Создание Makefile для сборки и тестирования проекта.

#### Технологии
- C++17
- GTest
- Google Style Guide
- Qt

### Результаты и достижения

В проекте "Snake" я создал библиотеку с логикой игры и графический интерфейс на C++17.

Я научился:
- Проектирование и разделение архитектуры на части:
    - Я разделил проект на две основные части: библиотека, которая отвечает за логику игры (размещена в `src/brick_game/snake`), и графический интерфейс (GUI), реализованный с использованием Qt (в `src/gui/desktop`).
    - Разделение логики и интерфейса помогло лучше понять, как строить масштабируемые и поддерживаемые приложения. Вся логика управления игровым состоянием сосредоточена в библиотеке, что позволяет легко адаптировать её для других интерфейсов, таких как консольная версия.
  
- Конечный автомат состояний (`FSM`):
  - Для управления состояниями игры (например, "Игра", "Пауза", "Конец игры") я внедрил `конечный автомат`. Это дало мне лучшее понимание формализации процессов — я понял, как можно точно определить переходы между состояниями и условия для каждого из них.
  - FSM помог упростить логику и сделал её более структурированной, позволяя легко управлять сложными взаимодействиями в игре.
    
- Механики игры и система уровней:
  - Я реализовал основные механики, такие как движение змейки, увеличение длины после поедания "яблока", а также столкновение с границами и собой, приводящее к окончанию игры. Через эти задачи я лучше `освоил работу с логикой игрового цикла и методами обновления состояния`.
  - Добавил систему уровней, где каждый пятый балл повышает уровень и ускоряет движение змеи. Это научило меня `динамически адаптировать игровой процесс`, чтобы сделать его интереснее для пользователя.
    
- Управление вводом с клавиатуры:
  - Настроил управление с использованием клавиш-стрелок для движения и возможность ускорять змею. Это позволило мне улучшить `навыки работы с событиями и научиться обрабатывать пользовательский ввод в режиме реального времени`.

- Графический интерфейс с использованием Qt:
  - Используя Qt, я создал интерфейс для отображения игры. Это включало в себя создание игровой области и зоны визуализации игровой статистики.
  
Я также настроил отображение сообщений (например, "Пауза" или "Конец игры"), которые появляются поверх игрового экрана, если игра меняет свое состояние.

- Тестирование с GTest и покрытие кода:
  - Покрыл код тестами более чем на 90% с использованием Google Test (GTest), что позволило мне не только повысить надежность проекта, но и увидеть, как важно иметь автоматические проверки для сложных систем.
  - Тестирование включало все основные функции — от изменения длины змеи до проверки граничных условий в управлении игровыми состояниями.
    
В процессе работы над этим проектом я не только закрепил свои знания в С++17, но и освоил принципы построения архитектуры, работающей на основе четкого разделения ответственности между компонентами. Теперь я лучше понимаю, как управлять состояниями игры, обрабатывать события и тестировать код, что станет отличной базой для будущих проектов.

---

# 3DViewer v2.0

### Описание
Программа для визуализации 3D каркасных моделей на C++17. Поддерживает загрузку моделей из файлов формата OBJ и выполнение аффинных преобразований.

### Ключевые особенности

#### Архитектура
- Программа построена на основе паттерна MVC.
- Реализованы паттерны фасад, стратегия и команда.

#### Функциональность
- Поддержка загрузки моделей из OBJ-файлов с отображением вершин и поверхностей.
- Аффинные преобразования: перемещение, поворот и масштабирование модели.
- Графический интерфейс с кнопками для управления и полями для вывода информации о модели.

#### Производительность
- Обработка моделей с количеством вершин до 1,000,000 без зависаний интерфейса.

#### Дополнительные функции
- Настройка типа проекции (параллельная и центральная).
- Сохранение изображений в форматах BMP и JPEG, запись скринкастов в GIF.

#### Инструменты
- C++17
- Google Style Guide
- Qt
