#ifndef S21_TRANSFORMATION_H_
#define S21_TRANSFORMATION_H_

#include "../../../models/include/Model.h"

namespace s21 {

/**
 * @brief Абстрактный класс для трансформаций (паттерн Стратегия)
 *
 * Этот класс используется для реализации различных типов трансформаций,
 * таких как перемещение, поворот, масштабирование и изменение цвета.
 * Конкретные трансформации должны наследоваться от этого класса и
 * реализовывать метод `apply`.
 */
class Transformation {
 public:
  /**
   * @brief Применить трансформацию к модели
   * @param model Модель, к которой будет применена трансформация
   */
  virtual void apply(Model& model) = 0;

  /**
   * @brief Виртуальный деструктор
   */
  virtual ~Transformation() = default;
};

/**
 * @brief Трансформация для перемещения модели на сцене
 *
 * Этот класс применяется для изменения положения модели по осям x, y, z.
 */
class Translate final : public Transformation {
 private:
  float x_, y_, z_;

 public:
  /**
   * @brief Конструктор для создания трансформации перемещения
   * @param x Смещение по оси X
   * @param y Смещение по оси Y
   * @param z Смещение по оси Z
   */
  Translate(const float x, const float y, const float z)
      : x_(x), y_(y), z_(z) {}

  /**
   * @brief Применить трансформацию к модели (переместить модель)
   * @param model Модель, которую нужно переместить
   */
  void apply(Model& model) override { model.translate(x_, y_, z_); }
};

/**
 * @brief Трансформация для вращения модели на сцене
 *
 * Класс используется для поворота модели вокруг осей X, Y и Z на заданные углы.
 */
class Rotate final : public Transformation {
 private:
  float angleX_, angleY_, angleZ_;

 public:
  /**
   * @brief Конструктор для создания трансформации вращения
   * @param angleX Угол вращения вокруг оси X (в градусах)
   * @param angleY Угол вращения вокруг оси Y (в градусах)
   * @param angleZ Угол вращения вокруг оси Z (в градусах)
   */
  Rotate(const float angleX, const float angleY, const float angleZ)
      : angleX_(angleX), angleY_(angleY), angleZ_(angleZ) {}

  /**
   * @brief Применить трансформацию к модели (повернуть модель)
   * @param model Модель, которую нужно повернуть
   */
  void apply(Model& model) override { model.rotate(angleX_, angleY_, angleZ_); }
};

/**
 * @brief Трансформация для масштабирования модели на сцене
 *
 * Класс применяется для изменения размера модели на основе коэффициента
 * масштаба.
 */
class Scale final : public Transformation {
 private:
  float scaleFactor_;

 public:
  /**
   * @brief Конструктор для создания трансформации масштабирования
   * @param scaleFactor Коэффициент масштабирования (1.0 = без изменения, <1.0 =
   * уменьшение, >1.0 = увеличение)
   */
  explicit Scale(const float scaleFactor) : scaleFactor_(scaleFactor) {}

  /**
   * @brief Применить трансформацию к модели (масштабировать модель)
   * @param model Модель, которую нужно масштабировать
   */
  void apply(Model& model) override { model.scale(scaleFactor_); }
};

/**
 * @brief Трансформация для изменения цвета линий модели
 *
 * Этот класс используется для изменения цвета линий модели, принимая цвет в
 * формате RGB (или RGBA).
 */
class LineColor final : public Transformation {
 private:
  float red_, green_, blue_, alpha_;

 public:
  /**
   * @brief Конструктор для создания трансформации цвета линий
   * @param red Интенсивность красного канала (0.0 - 1.0)
   * @param green Интенсивность зеленого канала (0.0 - 1.0)
   * @param blue Интенсивность синего канала (0.0 - 1.0)
   * @param alpha Прозрачность (0.0 - полностью прозрачный, 1.0 - полностью
   * непрозрачный). По умолчанию 1.0
   */
  LineColor(const float red, const float green, const float blue,
            const float alpha = 1.0f)
      : red_(red), green_(green), blue_(blue), alpha_(alpha) {}

  /**
   * @brief Применить трансформацию к модели (изменить цвет линий)
   * @param model Модель, у которой будет изменен цвет линий
   */
  void apply(Model& model) override {
    model.setLineColor(red_, green_, blue_, alpha_);
  }
};

/**
 * @brief Класс для изменения цвета вершин модели
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения цвета вершин в модели. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения цвета вершин.
 *
 * @details Конструктор класса принимает значения для компонентов
 * цвета (красный, зеленый, синий) и альфа-канала. Эти значения
 * хранятся как приватные члены класса и используются в методе
 * `apply`, чтобы вызвать метод `setVertexColor` модели,
 * устанавливая новый цвет вершин.
 *
 * @note Значение альфа-канала по умолчанию установлено в 1.0, что
 * соответствует полной непрозрачности.
 */
class VertexColor final : public Transformation {
 private:
  float red_;    ///< Компонент красного цвета (0.0 - 1.0)
  float green_;  ///< Компонент зеленого цвета (0.0 - 1.0)
  float blue_;   ///< Компонент синего цвета (0.0 - 1.0)
  float alpha_;  ///< Альфа-канал (прозрачность) цвета (0.0 - 1.0)

 public:
  /**
   * @brief Конструктор класса VertexColor
   *
   * Создает экземпляр класса VertexColor с заданными компонентами цвета.
   *
   * @param red Компонент красного цвета (0.0 - 1.0)
   * @param green Компонент зеленого цвета (0.0 - 1.0)
   * @param blue Компонент синего цвета (0.0 - 1.0)
   * @param alpha Альфа-канал (прозрачность) цвета (по умолчанию 1.0)
   */
  explicit VertexColor(const float red, const float green, const float blue,
                       const float alpha = 1.0f)
      : red_(red), green_(green), blue_(blue), alpha_(alpha) {}

  /**
   * @brief Применение изменения цвета вершин к модели
   *
   * Этот метод изменяет цвет вершин в модели, вызывая метод
   * `setVertexColor` у объекта модели с заданными значениями цвета.
   *
   * @param model Объект модели, к которому применяется изменение цвета
   */
  void apply(Model& model) override {
    model.setVertexColor(red_, green_, blue_, alpha_);
  }
};

/**
 * @brief Класс для изменения цвета фона модели
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения цвета фона в модели. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения цвета фона.
 *
 * @details Конструктор класса принимает значения для компонентов
 * цвета (красный, зеленый, синий) и альфа-канала. Эти значения
 * хранятся как приватные члены класса и используются в методе
 * `apply`, чтобы вызвать метод `setBackgroundColor` модели,
 * устанавливая новый цвет фона.
 *
 * @note Значение альфа-канала по умолчанию установлено в 1.0, что
 * соответствует полной непрозрачности.
 */
class BackgroundColor final : public Transformation {
 private:
  float red_;    ///< Компонент красного цвета (0.0 - 1.0)
  float green_;  ///< Компонент зеленого цвета (0.0 - 1.0)
  float blue_;   ///< Компонент синего цвета (0.0 - 1.0)
  float alpha_;  ///< Альфа-канал (прозрачность) цвета (0.0 - 1.0)

 public:
  /**
   * @brief Конструктор класса BackgroundColor
   *
   * Создает экземпляр класса BackgroundColor с заданными компонентами цвета.
   *
   * @param red Компонент красного цвета (0.0 - 1.0)
   * @param green Компонент зеленого цвета (0.0 - 1.0)
   * @param blue Компонент синего цвета (0.0 - 1.0)
   * @param alpha Альфа-канал (прозрачность) цвета (по умолчанию 1.0)
   */
  explicit BackgroundColor(const float red, const float green, const float blue,
                           const float alpha = 1.0f)
      : red_(red), green_(green), blue_(blue), alpha_(alpha) {}

  /**
   * @brief Применение изменения цвета фона к модели
   *
   * Этот метод изменяет цвет фона в модели, вызывая метод
   * `setBackgroundColor` у объекта модели с заданными значениями цвета.
   *
   * @param model Объект модели, к которому применяется изменение цвета
   */
  void apply(Model& model) override {
    model.setBackgroundColor(red_, green_, blue_, alpha_);
  }
};

/**
 * @brief Класс для изменения типа проекции
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения типа проекции. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения типа проекции.
 *
 * @details Конструктор класса принимает значения для компонента
 * типа. Это значение
 * хранится как приватный член класса и используется в методе
 * `apply`, чтобы вызвать метод `setProjectionType` модели,
 * устанавливая новый тип проекции.
 *
 */
class ProjectionType final : public Transformation {
 private:
  std::string& type_;

 public:
  /**
   * @brief Конструктор класса ProjectionType
   *
   * Создает экземпляр класса ProjectionType с заданным значением типа проекции.
   *
   * @param type Тип проекции
   */
  explicit ProjectionType(std::string& type) : type_(type) {}

  /**
   * @brief Применение изменения типа проекции к модели
   *
   * Этот метод изменяет тип проекции в модели, вызывая метод
   * `setProjectionType` у объекта модели с заданными значениями типа.
   *
   * @param model Объект модели, к которому применяется изменение цвета
   */
  void apply(Model& model) override { model.setProjectionType(type_); }
};

/**
 * @brief Класс для изменения типа линии ребра
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения типа проекции. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения типа линии ребра.
 *
 * @details Конструктор класса принимает значения для компонента
 * типа. Это значение
 * хранится как приватный член класса и используется в методе
 * `apply`, чтобы вызвать метод `setLineType` модели,
 * устанавливая новый тип линии ребра.
 *
 */
class LineType final : public Transformation {
 private:
  std::string& type_;

 public:
  /**
   * @brief Конструктор класса LineType
   *
   * Создает экземпляр класса LineType с заданным значением типа проекции.
   *
   * @param type Тип линии ребра
   */
  explicit LineType(std::string& type) : type_(type) {}

  /**
   * @brief Применение изменения типа проекции к модели
   *
   * Этот метод изменяет тип проекции в модели, вызывая метод
   * `setLineType` у объекта модели с заданными значениями типа.
   *
   * @param model Объект модели, к которому применяется изменение цвета
   */
  void apply(Model& model) override { model.setLineType(type_); }
};

/**
 * @brief Класс для изменения типа отображения вершин
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения типа проекции. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения типа отображения вершин.
 *
 * @details Конструктор класса принимает значения для компонента
 * типа. Это значение
 * хранится как приватный член класса и используется в методе
 * `apply`, чтобы вызвать метод `setVertexDisplay` модели,
 * устанавливая новый тип отображения вершин.
 *
 */
class VertexDisplay final : public Transformation {
 private:
  std::string& type_;

 public:
  /**
   * @brief Конструктор класса VertexDisplay
   *
   * Создает экземпляр класса VertexDisplay с заданным значением типа проекции.
   *
   * @param type Тип линии ребра
   */
  explicit VertexDisplay(std::string& type) : type_(type) {}

  /**
   * @brief Применение изменения типа проекции к модели
   *
   * Этот метод изменяет тип проекции в модели, вызывая метод
   * `setVertexDisplay` у объекта модели с заданными значениями типа.
   *
   * @param model Объект модели, к которому применяется изменение цвета
   */
  void apply(Model& model) override { model.setVertexDisplay(type_); }
};

/**
 * @brief Класс для изменения типа размера ребер
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения типа проекции. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения типа размера ребер.
 *
 * @details Конструктор класса принимает значения для компонента
 * типа. Это значение
 * хранится как приватный член класса и используется в методе
 * `apply`, чтобы вызвать метод `setVertexSize` модели,
 * устанавливая новый тип размера ребер.
 *
 */
class VertexSize final : public Transformation {
 private:
  std::string& type_;

 public:
  /**
   * @brief Конструктор класса VertexSize
   *
   * Создает экземпляр класса VertexSize с заданным значением типа проекции.
   *
   * @param type Тип линии ребра
   */
  explicit VertexSize(std::string& type) : type_(type) {}

  /**
   * @brief Применение изменения типа проекции к модели
   *
   * Этот метод изменяет тип проекции в модели, вызывая метод
   * `setVertexSize` у объекта модели с заданными значениями типа.
   *
   * @param model Объект модели, к которому применяется изменение цвета
   */
  void apply(Model& model) override { model.setVertexSize(type_); }
};

/**
 * @brief Класс для изменения типа толщины линий
 *
 * Этот класс представляет собой конкретную реализацию стратегии
 * для изменения типа толщины линий. Он наследует от абстрактного
 * класса `Transformation` и переопределяет метод `apply`, который
 * принимает объект модели и применяет к нему изменения типа толщины линий.
 *
 * @details Конструктор класса принимает значения для компонента
 * типа. Это значение
 * хранится как приватный член класса и используется в методе
 * `apply`, чтобы вызвать метод `setLineSize` модели,
 * устанавливая новый тип толщины линий.
 *
 */
class LineSize final : public Transformation {
 private:
  std::string& size_;

 public:
  /**
   * @brief Конструктор класса LineSize
   *
   * Создает экземпляр класса LineSize с заданным значением типа толщины линий.
   *
   * @param size Тип толщины линий
   */
  explicit LineSize(std::string& size) : size_(size) {}

  /**
   * @brief Применение изменения типа толщины линий
   *
   * Этот метод изменяет тип толщины линий, вызывая метод
   * `setLineSize` у объекта модели с заданными значениями типа.
   *
   * @param model Объект модели, к которому применяется изменение типа линий
   */
  void apply(Model& model) override { model.setLineSize(size_); }
};
}  // namespace s21

#endif  // S21_TRANSFORMATION_H_
